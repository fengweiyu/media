<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="UTF-8"> 
    <title>MediaConvert.js demo</title>
  </head>

  <body>
    
    <script type="text/javascript" src="./build/MediaConvert.js"></script>
    <center>
        <h1><a href="">MediaConvert.js demo</a></h1>
    </center>
        <h2>请选择一个输入文件:</h2>
    <center>
        <input type="file" id="fileInput" accept=".flv,.h264,.h265,.pri"/> 
    </center> 
        <h2>请选择一个输出格式:</h2>
    <center>
        <label>  
            <input type="checkbox" name="options" value="pri" > pri  
        </label> 
        <label>  
            <input type="checkbox" name="options" value="flv" > flv  
        </label>  
        <label>  
            <input type="checkbox" name="options" value="mp4" checked> mp4  
        </label>  
        <label>  
            <input type="checkbox" name="options" value="VideoRaw"> VideoRaw  
        </label>
        <label>  
            <input type="checkbox" name="options" value="AudioRaw"> AudioRaw  
        </label> 
        <br><br>
        <button id="saveButton" disabled>格式转换</button>
        <br><br>
        <video id="localVideoElement" playsinline controls autoplay muted style="width: 80%;height: auto;display: none;"></video>
    </center>

    <script>
        Module.onRuntimeInitialized = function() 
        {
            console.log('onRuntimeInitialized:'); 
        }
        const localVideoElement = document.getElementById('localVideoElement');
        const mediaSource = new MediaSource();
        // 获取所有复选框  
        const checkboxes = document.querySelectorAll('input[type="checkbox"][name="options"]');  

        checkboxes.forEach(checkbox => 
        {  
            checkbox.addEventListener('change', function() 
            {  
                if (this.checked) {  
                    // 如果当前复选框被选中，取消选中其他复选框  
                    checkboxes.forEach(cb => 
                    {  
                        if (cb !== this) 
                        {  
                            cb.checked = false; // 取消其他复选框的选中状态  
                        }  
                    });  
                }  
            });  
        });  
        const fileInput = document.getElementById('fileInput');  
        const saveButton = document.getElementById('saveButton');  
        let arrayBuffer;  
        let filename;
        let filetype;
        fileInput.addEventListener('change', function(event) 
        {  
            const file = event.target.files[0]; // 获取选中的文件  
            if (file) 
            {  
                const reader = new FileReader(); 
                var name=file.name;                
                const parts = name.split('.'); // 根据 . 分割文件名 
                filename=parts[0];
                filetype='.'+parts[1];
                //filename=name.substring(0, name.lastIndexOf('.')); 
                // 读取文件为 ArrayBuffer  
                reader.onload = function(e) 
                {  
                    arrayBuffer = e.target.result; // 将文件内容保存到 ArrayBuffer  
                    //console.log('File read as ArrayBuffer:', arrayBuffer);  
                    saveButton.disabled = false; // 启用保存按钮  
                    console.log('file:'+filename+' type:'+filetype+' byteLength:'+arrayBuffer.byteLength); 
                };  
                reader.readAsArrayBuffer(file); // 开始读取文件  
            }  
        });  
        saveButton.addEventListener('click', function() 
        {  
            if (!arrayBuffer)
            {
                console.log('file err:'+filename+' type:'+filetype+' byteLength:'+arrayBuffer.byteLength); 
                return;      
            }
            console.log('file addEventListener:'+filename+' type:'+filetype+' byteLength:'+arrayBuffer.byteLength);    
            // 选择所有的复选框  
            //Module.onRuntimeInitialized = function() 
            localVideoElement.src = URL.createObjectURL(mediaSource); 
            mediaSource.addEventListener('sourceopen', function() 
            {  
                var sourceBuffer=null;  
                const typedArray = convert(arrayBuffer,GetDstName());
                if (typedArray) 
                { // 成功创建，输出内容
                    if(GetDstName() == ".mp4")
                    {
                        if(null == sourceBuffer)
                        {// codecs="avc1.42E01E, mp4a.40.2" h264 aac   
                            var VideoCodec=null;
                            var AudioCodec=null;
                            [v,a]=GetMediaDstEnc();
                            if (v.includes("h264"))//video/webm; codecs="avc1.64001E"：用于 WebM 容器中的 H.264 视频（通常则使用 VP8 或 VP9）。
                            {//video/mp4; codecs="avc1.64001E"：用于 MP4 容器中的 H.264 视频。
                                VideoCodec="avc1.42E01E";//avc1.42E01E
                            }//video/mp2t; codecs="avc1.42E01E"：用于 MPEG-TS 容器中的 H.264 视频
                            else if (v.includes("h265"))
                            {//video/mp4; codecs="hevc"：用于 MPEG-4 容器格式中的 H.265 视频。
                                VideoCodec="hvc1.1.6.L93.B0";
                            }//用于传输流（如 TS 或 MPEG-TS）编码中的 H.265 视频。
                            if (a.includes("aac"))
                            {
                                AudioCodec="mp4a.40.2";//audio/mp4; codecs="mp4a.40.2"：这是一般用于 MP4 容器中的 AAC 音频格式。
                            }//audio/aac：用于裸 AAC 数据。
                            else if(a.includes("g711a"))
                            {
                                AudioCodec="alaw";//audio/mp4; codecs="law"：表示使用 G.711 A-law 编码的音频数据。
                            }//audio/g711：用于直接表示 G.711 编码的数据。
                            if(null == VideoCodec || null ==AudioCodec)
                            {
                                console.log('GetMediaDstEnc err v '+VideoCodec+' a '+AudioCodec);    
                            }
                            else
                            {
                                sourceBuffer = mediaSource.addSourceBuffer('video/mp4; codecs="'+VideoCodec+','+AudioCodec+'"');
                                localVideoElement.style.display = 'block'; // 显示视频 = 'none'; // 隐藏视频  
                            }

                        }
                        if(null != sourceBuffer)
                            sourceBuffer.appendBuffer(typedArray);    
                    }   
                    DownloadMedia(typedArray,GetDstName());
                } 
                else
                {// 处理未成功创建的情况 
                    console.log('FormatConvert err'); 
                } 
                /*sourceBuffer.addEventListener('updateend', function() {  
                    if (!sourceBuffer.updating) {  
                        //mediaSource.endOfStream();  
                        //localVideoElement.play();  
                    }  
                }); */
            });
        }); 
        function DownloadMedia(typedArray,dstType)
        {
            // 创建 Blob 对象  
            const blob = new Blob([typedArray]);  
            // 创建下载链接  
            const url = URL.createObjectURL(blob);  
            const a = document.createElement('a');  
            a.href = url;  
            a.download = filename+dstType; // 指定下载文件名  
            document.body.appendChild(a);  
            a.click(); // 自动点击下载链接  
            document.body.removeChild(a); // 下载后移除临时链接  
            // 释放 Blob URL  
            URL.revokeObjectURL(url); 
        }
        function GetDstName()
        {
            const selectedHobbies = [];  
            // 遍历复选框，检测哪些被选中  
            checkboxes.forEach(checkbox => {  
                if (checkbox.checked) 
                {  
                    selectedHobbies.push(checkbox.value); // 添加到数组  
                }  
            }); 
            const dstName = '.'+selectedHobbies[0];
            return dstName;
        }
        function GetMediaDstEnc()
        {
            var bufDstMaxLen=10;
            let bufDstVideoEnc = Module._malloc(bufDstMaxLen);
            let bufDstAudioEnc = Module._malloc(bufDstMaxLen);
            var ret = Module._GetEncodeType(bufDstVideoEnc,bufDstMaxLen,bufDstAudioEnc,bufDstMaxLen);
            let VideoArray = new Uint8Array(bufDstMaxLen);
            VideoArray.set(new Uint8Array(Module.HEAPU8.buffer, bufDstVideoEnc, bufDstMaxLen)); // 将C中的数组拷贝到JS数组中
            let AudioArray = new Int8Array(bufDstMaxLen);
            AudioArray.set(new Uint8Array(Module.HEAP8.buffer, bufDstAudioEnc, bufDstMaxLen)); // 将C中的数组拷贝到JS数组中
            const stringVideo = String.fromCharCode.apply(null, VideoArray);  
            const stringAudio = String.fromCharCode.apply(null, AudioArray);  
            Module._free(bufDstVideoEnc);
            Module._free(bufDstAudioEnc);
            return [stringVideo,stringAudio];
        }
        function convert(srcBuffer,dstName) 
        {         
            const dstType = dstName;
            /*const arr = new Float32Array([1.0, 2.0, 3.0]); // 示例数组  
            const size = arr.length * arr.BYTES_PER_ELEMENT; // 计算大小  
            const ptr = instance._malloc(size); // 在Wasm内存中申请空间  
            instance.HEAPF32.set(arr, ptr / arr.BYTES_PER_ELEMENT); // 拷贝数据到内存  
            instance._your_function(ptr, arr.length); // 调用C函数，传入数据指针和数组长度  
            instance._free(ptr); // 调用完后释放内存  */
            let arrDstType = intArrayFromString(dstType).concat(0);
	        let bufDstType = Module._malloc(arrDstType.length);
	        Module.HEAPU8.set(arrDstType, bufDstType);
	        let arrSrctype = intArrayFromString(filetype).concat(0);
	        let bufSrctype = Module._malloc(arrSrctype.length);
	        Module.HEAPU8.set(arrSrctype, bufSrctype);
            const uint8View = new Uint8Array(srcBuffer);//arrayBuffer
	        let bufSrcFrame = Module._malloc(uint8View.byteLength);
	        Module.HEAPU8.set(uint8View,bufSrcFrame);//bufSrcFrame,arrayBuffer,要Uint8Array才可以设置进去拷贝，arrayBuffer不能拷贝
            //const lengthPtr = Module._malloc(arrayBuffer.byteLength);
            //const uint8View = new Uint8Array(Module.HEAPU8.buffer, bufSrcFrame, arrayBuffer.byteLength).set(arrayBuffer);
            Module._InputData(bufSrcFrame,uint8View.byteLength,bufSrctype,bufDstType);
            //const buffer = new ArrayBuffer(arrayBuffer.byteLength); 
            //const uint8View = new Uint8Array(buffer); 
            var bufDstMaxLen=uint8View.byteLength+(10*1024*1024);
            let bufDstFrame = Module._malloc(bufDstMaxLen);
            var ret=0;
            var len=0; 
            do {  
                len+=ret;   
                ret = Module._GetData(bufDstFrame+len,bufDstMaxLen-len);//arrayBuffer.buffer arrayBuffer.byteOffset
            } while (ret>0); 
            let copiedArray = new Uint8Array(len);
            copiedArray.set(new Uint8Array(Module.HEAPU8.buffer, bufDstFrame, len)); // 将C中的数组拷贝到JS数组中
            Module._free(bufDstType);
            Module._free(bufSrctype);
            Module._free(bufSrcFrame);
            Module._free(bufDstFrame);
            if(len>0)    
                return copiedArray;
            return null;            
        } 
        function formatDate(date) 
        {  
            const currentDate = new Date();  
            const year = currentDate.getFullYear();  
            const month = String(currentDate.getMonth() + 1).padStart(2, '0'); // 月份从0开始  
            const day = String(currentDate.getDate()).padStart(2, '0');  
            const hours = String(currentDate.getHours()).padStart(2, '0');  
            const minutes = String(currentDate.getMinutes()).padStart(2, '0');  
            const seconds = String(currentDate.getSeconds()).padStart(2, '0');  
            const milliseconds = String(currentDate.getMilliseconds()).padStart(3, '0');

            const formattedDate = `${year}-${month}-${day} ${hours}:${minutes}:${seconds}.${milliseconds}`; 
            return formattedDate;  
        } 
        //自执行函数：我们使用一个自执行函数来封装代码，确保不会污染全局命名空间
        (function() {  
            const originalLog = console.log;  

            console.log = function(...args) {  
                const now = new Date();  
                const timeStamp = formatDate(now);  //now.toISOString(); // 或者使用自定义格式  
                originalLog.apply(console, [`[${timeStamp}]`, ...args]);  
            };  
        })(); 
        
    </script>
  </body>
</html>
